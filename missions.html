<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nhi·ªám v·ª• & Khen th∆∞·ªüng ‚Äî Nh·∫≠t k√Ω NƒÉng l·ª±c</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Th√™m m·ªôt s·ªë CSS nh·ªè chuy√™n cho page n√†y (d√πng chung style.css ch√≠nh) */
    .page { padding: 36px 20px; max-width:1100px; margin: 0 auto; }
    .missions-grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap:16px; margin-top:18px; }
    .mission-card { padding:14px; border-radius:12px; background:var(--card); border:1px solid var(--border); }
    .mission-card h4 { margin:0 0 8px 0; }
    .small-muted { color:var(--muted); font-size:0.95rem; }
    .xp-banner { margin-top:10px; display:flex; gap:12px; align-items:center; justify-content:space-between;}
    #messagesBox { max-height:260px; overflow:auto; padding:8px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border:1px solid var(--border); }
    .msg { padding:10px; border-radius:10px; margin-bottom:8px; background: rgba(0,0,0,0.12) }
    .leaderboard-list { list-style:none; padding:0; margin:0;}
    .leaderboard-list li { padding:10px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; }
    .unlock { color:var(--accent); font-weight:700 }
  </style>
</head>
<body>
  <!-- Nav (d√πng c√πng style) -->
  <header class="nav">
    <div class="container nav-inner">
      <a href="index.html" class="brand">NH·∫¨T K√ç<span>NƒÇNG L·ª∞C</span></a>
      <div class="menu" id="nav-menu">
        <a href="index.html">Trang ch·ªß</a>
        <a href="journal.html">Nh·∫≠t k√Ω</a>
        <a href="features.html">T√≠nh nƒÉng</a>
        <a href="missions.html" class="active">Nhi·ªám v·ª•</a>
      </div>
      <button id="theme-toggle" class="theme-toggle-btn" aria-label="Chuy·ªÉn ch·ªß ƒë·ªÅ">üåô</button>
    </div>
  </header>

  <main class="page">
    <h1>üéØ Nhi·ªám v·ª• & XP</h1>
    <p class="small-muted">Ho√†n th√†nh nhi·ªám v·ª• ƒë·ªÉ nh·∫≠n XP, m·ªü huy hi·ªáu v√† leo b·∫£ng x·∫øp h·∫°ng. Chat ·∫©n danh cho c·ªông ƒë·ªìng.</p>

    <div class="xp-banner">
      <div>
        <div class="small-muted">T·ªïng XP c·ªßa b·∫°n</div>
        <div style="font-size:20px;font-weight:800"><span id="xpValue">0</span> XP <span id="unlockBadge" class="unlock" style="display:none">¬∑ M·ªü kh√≥a AI l·ªô tr√¨nh!</span></div>
        <div class="small-muted">C·∫•p b·∫≠c: <span id="rankLabel">Ng∆∞·ªùi kh·ªüi ƒë·∫ßu</span></div>
      </div>
      <div>
        <button id="loginQuick" class="btn">ƒêƒÉng nh·∫≠p</button>
        <button id="syncBtn" class="btn">ƒê·ªìng b·ªô</button>
      </div>
    </div>

    <section>
      <h3 style="margin-top:18px">Nhi·ªám v·ª• Tu·∫ßn n√†y</h3>
      <div class="missions-grid" id="missionsGrid">
        <!-- JS s·∫Ω render nhi·ªám v·ª• ·ªü ƒë√¢y -->
      </div>
    </section>

    <section style="margin-top:22px">
      <div style="display:grid;grid-template-columns:1fr 320px;gap:16px">
        <div class="mission-card">
          <h3>üí¨ G√≥c ·∫©n danh</h3>
          <p class="small-muted">Chia s·∫ª c·∫£m x√∫c, n·ªó l·ª±c, ho·∫∑c minh ch·ª©ng. Tin nh·∫Øn hi·ªÉn th·ªã realtime.</p>
          <div style="margin-top:8px">
            <input id="anonNick" placeholder="Bi·ªát danh (t√πy ch·ªçn)" style="width:100%;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)" />
            <textarea id="anonText" placeholder="Vi·∫øt g√¨ ƒë√≥..." style="width:100%;margin-top:8px;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)"></textarea>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="sendAnon" class="btn">G·ª≠i</button>
              <button id="refreshMsgs" class="btn ghost">L√†m m·ªõi</button>
            </div>
          </div>
          <div id="messagesBox" style="margin-top:12px"></div>
        </div>

        <aside class="mission-card">
          <h3>üèÜ B·∫£ng x·∫øp h·∫°ng</h3>
          <p class="small-muted">Nh·ªØng ng∆∞·ªùi c√≥ nhi·ªÅu XP & ho√†n th√†nh nhi·ªÅu nhi·ªám v·ª• nh·∫•t</p>
          <ul id="leaderboard" class="leaderboard-list" style="margin-top:10px"></ul>
        </aside>
      </div>
    </section>

    <section style="margin-top:18px">
      <button id="analyzeAI" class="btn-ai">Ph√¢n t√≠ch AI (offline)</button>
      <div id="aiResult" class="ai-box small-muted" style="display:none;margin-top:10px"></div>
    </section>
  </main>

  <footer class="footer">¬© 2025 Nh·∫≠t k√Ω NƒÉng l·ª±c</footer>

  <script type="module">
    // ===== Firebase SDK modules (CDN) =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc, onSnapshot, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

    // === Firebase config (same as main.js) ===
    const firebaseConfig = {
      apiKey: "AIzaSyCtp4izpF1GCH2qWpeLtZOdk33A_iNKzqg",
      authDomain: "nknl-d7b54.firebaseapp.com",
      projectId: "nknl-d7b54",
      storageBucket: "nknl-d7b54.firebasestorage.app",
      messagingSenderId: "792185587281",
      appId: "1:792185587281:web:585e98f2f87d7d59031a70",
      measurementId: "G-TC7XHSSCBX"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ===== App state & elements =====
    const missionsGrid = document.getElementById('missionsGrid');
    const xpValueEl = document.getElementById('xpValue');
    const rankLabel = document.getElementById('rankLabel');
    const unlockBadge = document.getElementById('unlockBadge');
    const sendAnonBtn = document.getElementById('sendAnon');
    const messagesBox = document.getElementById('messagesBox');
    const leaderboardEl = document.getElementById('leaderboard');
    const analyzeBtn = document.getElementById('analyzeAI');
    const aiResult = document.getElementById('aiResult');
    const loginQuick = document.getElementById('loginQuick');
    const syncBtn = document.getElementById('syncBtn');

    // Local fallback if not logged in
    const LS_XP = 'missions_xp_local';
    const LS_MSGS = 'missions_msgs_local';
    const LS_COMPLETE = 'missions_complete_local';

    // Predefined missions
    const DEFAULT_MISSIONS = [
      { id: 'm1', title: 'H·ªçc 20 t·ª´ m·ªõi', xp: 10, weekly: true },
      { id: 'm2', title: 'Vi·∫øt 3 d√≤ng c·∫£m nh·∫≠n', xp: 5, weekly: true },
      { id: 'm3', title: 'N·ªôp minh ch·ª©ng k·ªπ nƒÉng', xp: 20, weekly: false },
      { id: 'm4', title: 'ƒê√°nh gi√° 1 b·∫°n kh√°c', xp: 5, weekly: true }
    ];

    // initialize UI
    let currentUser = null;
    let localXP = Number(localStorage.getItem(LS_XP) || "0");
    let localCompleted = JSON.parse(localStorage.getItem(LS_COMPLETE) || "{}");

    // ===== Render missions list =====
    function renderMissions(completed = {}) {
      missionsGrid.innerHTML = '';
      DEFAULT_MISSIONS.forEach(m => {
        const card = document.createElement('div');
        card.className = 'mission-card';
        card.innerHTML = `
          <h4>${m.title}</h4>
          <div class="small-muted">+${m.xp} XP ¬∑ ${m.weekly ? 'Nhi·ªám v·ª• tu·∫ßn' : 'Nhi·ªám v·ª•'}</div>
          <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
            <label style="display:flex;align-items:center;gap:8px"><input data-id="${m.id}" type="checkbox" ${completed[m.id] ? 'checked':''} /> ƒê√£ ho√†n th√†nh</label>
            <button class="btn claim-btn" data-id="${m.id}">Nh·∫≠n</button>
          </div>
        `;
        missionsGrid.appendChild(card);
      });

      // checkbox listener -> save locally
      missionsGrid.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.addEventListener('change', async (e) => {
          const id = e.target.dataset.id;
          completed[id] = e.target.checked;
          localStorage.setItem(LS_COMPLETE, JSON.stringify(completed));
          // If user logged in, update their doc's completedTasks map
          if (currentUser) {
            const uDoc = doc(db, 'users', currentUser.uid);
            await updateUserCompletedOnFirestore(currentUser.uid, completed);
          }
        });
      });

      // claim buttons
      missionsGrid.querySelectorAll('.claim-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const id = e.target.dataset.id;
          // check if marked done
          const checkbox = missionsGrid.querySelector(`input[data-id="${id}"]`);
          if (!checkbox || !checkbox.checked) return alert('Vui l√≤ng ƒë√°nh d·∫•u ho√†n th√†nh tr∆∞·ªõc khi nh·∫≠n XP.');
          const mission = DEFAULT_MISSIONS.find(x => x.id === id);
          if (!mission) return;
          await awardXP(mission.xp, id);
        });
      });
    }

    // ===== XP logic =====
    async function awardXP(amount, missionId) {
      if (currentUser) {
        // update Firestore user's xp and leaderboard doc
        const userRef = doc(db, 'users', currentUser.uid);
        const userSnap = await getDoc(userRef);
        if (userSnap.exists()) {
          const data = userSnap.data();
          const newXP = (data.xp || 0) + amount;
          await setDoc(userRef, { xp: newXP, displayName: data.displayName || currentUser.email || 'Ng∆∞·ªùi d√πng' }, { merge: true });
          // update leaderboard doc
          const lbRef = doc(db, 'leaderboard', currentUser.uid);
          await setDoc(lbRef, { uid: currentUser.uid, name: data.displayName || currentUser.email || 'Ng∆∞·ªùi d√πng', xp: newXP, updatedAt: new Date().toISOString() }, { merge: true });
          // mark mission claimed to avoid double-claim: we can remove checkbox or disable button
          // (we'll keep local completed map to prevent immediate re-claim)
        } else {
          // user doc not found: create
          await setDoc(userRef, { xp: amount, displayName: currentUser.email || 'Ng∆∞·ªùi d√πng' }, { merge: true });
          await setDoc(doc(db,'leaderboard', currentUser.uid), { uid: currentUser.uid, name: currentUser.email || 'Ng∆∞·ªùi d√πng', xp: amount, updatedAt: new Date().toISOString() }, { merge: true });
        }
      } else {
        // not logged: local fallback
        localXP += amount;
        localStorage.setItem(LS_XP, String(localXP));
      }
      updateXPUI();
      alert(`B·∫°n nh·∫≠n ƒë∆∞·ª£c ${amount} XP!`);
    }

    // update XP UI from Firestore (if logged) or local
    async function updateXPUI() {
      if (currentUser) {
        const uRef = doc(db, 'users', currentUser.uid);
        const uSnap = await getDoc(uRef);
        const xp = (uSnap.exists() && uSnap.data().xp) ? uSnap.data().xp : 0;
        xpValueEl.textContent = xp;
        updateRankLabel(xp);
        if (xp >= 50) unlockBadge.style.display = 'inline';
        else unlockBadge.style.display = 'none';
      } else {
        xpValueEl.textContent = localXP;
        updateRankLabel(localXP);
        if (localXP >= 50) unlockBadge.style.display = 'inline';
        else unlockBadge.style.display = 'none';
      }
    }

    function updateRankLabel(xp) {
      let rank = 'Ng∆∞·ªùi kh·ªüi ƒë·∫ßu';
      if (xp >= 200) rank = 'Chuy√™n gia';
      else if (xp >= 100) rank = 'Th√†nh th·∫°o';
      else if (xp >= 50) rank = 'Ng∆∞·ªùi h·ªçc t√≠ch c·ª±c';
      else if (xp >= 20) rank = 'Kh√°m ph√°';
      rankLabel.textContent = rank;
    }

    // ===== Realtime chat (anonMessages collection) =====
    function renderMessages(docs) {
      messagesBox.innerHTML = '';
      docs.forEach(doc => {
        const data = doc.data ? doc.data() : doc; // support array of plain objects for local mode
        const nick = data.nick || '·∫®n danh';
        const text = data.text || '';
        const time = data.createdAt ? new Date(data.createdAt.toDate ? data.createdAt.toDate() : data.createdAt).toLocaleString() : '';
        const div = document.createElement('div');
        div.className = 'msg';
        div.innerHTML = `<div style="font-size:12px;color:var(--muted)">${nick} ¬∑ ${time}</div><div style="margin-top:6px">${escapeHtml(text)}</div>`;
        messagesBox.appendChild(div);
      });
      messagesBox.scrollTop = messagesBox.scrollHeight;
    }

    // hook Firestore realtime listener
    let msgsUnsub = null;
    function startMessagesListener() {
      const col = collection(db, 'anonMessages');
      const q = query(col, orderBy('createdAt', 'desc'), limit(50));
      msgsUnsub = onSnapshot(q, snap => {
        const arr = [];
        snap.forEach(d => arr.push(d));
        // reverse so oldest first
        renderMessages(arr.reverse());
      }, err => {
        console.error('msg listen err', err);
      });
    }

    // send anon message
    sendAnonBtn.addEventListener('click', async () => {
      const nick = document.getElementById('anonNick').value.trim();
      const text = document.getElementById('anonText').value.trim();
      if (!text) return alert('Nh·∫≠p tin nh·∫Øn tr∆∞·ªõc khi g·ª≠i.');
      const payload = {
        nick: nick || (currentUser ? (currentUser.displayName || currentUser.email) : '·∫®n danh'),
        text,
        createdAt: new Date()
      };
      try {
        if (currentUser) {
          // save with user context
          await addDoc(collection(db, 'anonMessages'), payload);
        } else {
          // if not logged -> store locally as fallback
          const arr = JSON.parse(localStorage.getItem(LS_MSGS) || "[]");
          arr.push({ ...payload, createdAt: new Date().toISOString() });
          localStorage.setItem(LS_MSGS, JSON.stringify(arr));
          // also render local list
          const localDocs = JSON.parse(localStorage.getItem(LS_MSGS) || "[]");
          renderMessages(localDocs.map(d => ({ nick: d.nick, text: d.text, createdAt: d.createdAt })));
        }
        document.getElementById('anonText').value = '';
      } catch (err) {
        console.error('send message err', err);
        alert('Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn: ' + err.message);
      }
    });

    document.getElementById('refreshMsgs').addEventListener('click', () => {
      if (currentUser) {
        // will be updated realtime via snapshot
        alert('Tin nh·∫Øn realtime ƒëang c·∫≠p nh·∫≠t t·ª± ƒë·ªông.');
      } else {
        const localDocs = JSON.parse(localStorage.getItem(LS_MSGS) || "[]");
        renderMessages(localDocs.map(d => ({ nick: d.nick, text: d.text, createdAt: d.createdAt })));
      }
    });

    // escape html
    function escapeHtml(s) {
      return String(s).replace(/[&<>"]/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c]));
    }

    // ===== Leaderboard realtime =====
    let lbUnsub = null;
    function startLeaderboardListener() {
      const col = collection(db, 'leaderboard');
      const q = query(col, orderBy('xp', 'desc'), limit(20));
      lbUnsub = onSnapshot(q, snap => {
        leaderboardEl.innerHTML = '';
        snap.forEach(doc => {
          const d = doc.data();
          const li = document.createElement('li');
          li.innerHTML = `<div style="font-weight:700">${escapeHtml(d.name || 'Ng∆∞·ªùi')}</div><div style="font-weight:700">${d.xp || 0} XP</div>`;
          leaderboardEl.appendChild(li);
        });
      });
    }

    // if not logged: create leaderboard view from localStorage (demo)
    function renderLocalLeaderboard() {
      // read localStorage 'local_leaderboard' or derive from local xp only
      const fake = JSON.parse(localStorage.getItem('local_leaderboard') || "[]");
      if (fake.length === 0) {
        // show local user only
        leaderboardEl.innerHTML = `<li><div style="font-weight:700">B·∫°n (local)</div><div style="font-weight:700">${localXP} XP</div></li>`;
        return;
      }
      leaderboardEl.innerHTML = '';
      fake.sort((a,b) => b.xp - a.xp).forEach(p => {
        const li = document.createElement('li');
        li.innerHTML = `<div style="font-weight:700">${escapeHtml(p.name)}</div><div style="font-weight:700">${p.xp} XP</div>`;
        leaderboardEl.appendChild(li);
      });
    }

    // ===== Sync user completed map to Firestore (merge) =====
    async function updateUserCompletedOnFirestore(uid, completedMap) {
      const uRef = doc(db, 'users', uid);
      try {
        await setDoc(uRef, { completed: completedMap }, { merge: true });
      } catch (err) {
        console.error('update completed err', err);
      }
    }

    // ===== onAuth state =====
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUser = user;
        // start listeners
        startMessagesListener();
        startLeaderboardListener();

        // load user doc xp & completed tasks
        try {
          const uRef = doc(db, 'users', user.uid);
          const uSnap = await getDoc(uRef);
          if (uSnap.exists()) {
            const data = uSnap.data();
            // set UI xp
            xpValueEl.textContent = data.xp || 0;
            updateRankLabel(data.xp || 0);
            // merge completed
            const completed = data.completed || JSON.parse(localStorage.getItem(LS_COMPLETE) || "{}");
            localStorage.setItem(LS_COMPLETE, JSON.stringify(completed));
            renderMissions(completed);
          } else {
            // new user
            await setDoc(uRef, { xp: localXP || 0, displayName: user.displayName || user.email || 'Ng∆∞·ªùi d√πng' }, { merge: true });
            await setDoc(doc(db,'leaderboard', user.uid), { uid: user.uid, name: user.displayName || user.email || 'Ng∆∞·ªùi d√πng', xp: localXP || 0, updatedAt: new Date().toISOString() }, { merge: true });
            renderMissions(JSON.parse(localStorage.getItem(LS_COMPLETE) || "{}"));
            xpValueEl.textContent = localXP || 0;
            updateRankLabel(localXP || 0);
          }
        } catch (err) {
          console.error('load user doc err', err);
          renderMissions(JSON.parse(localStorage.getItem(LS_COMPLETE) || "{}"));
        }

      } else {
        // not logged
        currentUser = null;
        // stop firestore listeners if exist
        if (msgsUnsub) { msgsUnsub(); msgsUnsub = null; }
        if (lbUnsub) { lbUnsub(); lbUnsub = null; }
        // render local fallback
        const localMsgs = JSON.parse(localStorage.getItem(LS_MSGS) || "[]");
        renderMessages(localMsgs.map(d => ({ nick: d.nick, text: d.text, createdAt: d.createdAt })));
        renderLocalLeaderboard();
        renderMissions(JSON.parse(localStorage.getItem(LS_COMPLETE) || "{}"));
        updateXPUI();
      }
    });

    // ===== Utility: update Firestore user's xp when they get local xp and then login (sync button) =====
    syncBtn.addEventListener('click', async () => {
      if (!currentUser) return alert('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ ƒë·ªìng b·ªô l√™n server.');
      try {
        // merge localXP into firestore xp
        const uRef = doc(db, 'users', currentUser.uid);
        const uSnap = await getDoc(uRef);
        const serverXP = uSnap.exists() ? (uSnap.data().xp || 0) : 0;
        const merged = serverXP + localXP;
        await setDoc(uRef, { xp: merged, displayName: currentUser.displayName || currentUser.email }, { merge: true });
        await setDoc(doc(db,'leaderboard', currentUser.uid), { uid: currentUser.uid, name: currentUser.displayName || currentUser.email, xp: merged, updatedAt: new Date().toISOString() }, { merge: true });
        // clear local
        localXP = 0; localStorage.removeItem(LS_XP);
        alert('ƒê·ªìng b·ªô th√†nh c√¥ng!');
        updateXPUI();
      } catch (err) {
        console.error('sync err', err);
        alert('ƒê·ªìng b·ªô th·∫•t b·∫°i: ' + err.message);
      }
    });

    // Quick "login" button: redirect to login page / or open login.html
    loginQuick.addEventListener('click', () => {
      window.location.href = 'login.html';
    });

    // ===== Offline AI analysis (simple) =====
    analyzeBtn.addEventListener('click', async () => {
      // get recent xp history? For demo, we'll analyze leaderboard top values as proxy
      if (currentUser) {
        // fetch user's last 10 xp changes from leaderboard update timestamps not available -> do simple message-based sentiment
        aiResult.style.display = 'block';
        aiResult.innerText = 'üß† Ph√¢n t√≠ch ƒë∆°n gi·∫£n: B·∫°n ƒëang c√≥ ho·∫°t ƒë·ªông ƒë·ªÅu ƒë·∫∑n. (Demo offline)'; 
      } else {
        aiResult.style.display = 'block';
        aiResult.innerText = '‚ö†Ô∏è Ch∆∞a ƒëƒÉng nh·∫≠p ‚Äî ph√¢n t√≠ch ch·ªâ c√≥ th·ªÉ ch·∫°y khi c√≥ d·ªØ li·ªáu ng∆∞·ªùi d√πng.';
      }
    });

    // initial render for non-auth quick view
    renderMissions(JSON.parse(localStorage.getItem(LS_COMPLETE) || "{}"));
    updateXPUI();

  </script>
</body>
</html>
